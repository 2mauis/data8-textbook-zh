# 五、表格

表格是表示数据集的基本对象类型。 表格可以用两种方式查看：

+   具名列的序列，每列都描述数据集中所有条目的一个方面，或者
+   行的序列，每行都包含数据集中单个条目的所有信息。

为了使用表格，导入所有称为`datascience`的模块，这是为这篇文章创建的模块。

```py
from datascience import *
```

空表格可以使用`Table`创建。空表格是实用的，因为他可以扩展来包含新行和新列。

```py
Table()
```

表格上的`with_columns`方法使用带有附加标签的列，构造一个新表。 表格的每一列都是一个数组。 为了将一个新列添加到表中，请使用标签和数组调用`with_columns`。 （`with_column`方法具有相同的效果。）

下面，我们用一个没有列的空表开始每个例子。

```py
Table().with_columns('Number of petals', make_array(8, 34, 5))
```

| Number of petals |
| --- |
| 8 |
| 34 |
| 5 |

为了添加两个（或更多）新列，请为每列提供一个数组和标签。 所有列必须具有相同的长度，否则会发生错误。

```py
Table().with_columns(
    'Number of petals', make_array(8, 34, 5),
    'Name', make_array('lotus', 'sunflower', 'rose')
)
```


| Number of petals | Name |
| --- | --- |
| 8 | lotus |
| 34 | sunflower |
| 5 | rose |

我们可以给这个表格一个名词，之后使用另外一列扩展表格。

```py
flowers = Table().with_columns(
    'Number of petals', make_array(8, 34, 5),
    'Name', make_array('lotus', 'sunflower', 'rose')
)

flowers.with_columns(
    'Color', make_array('pink', 'yellow', 'red')
)
```


| Number of petals | Name | Color |
| --- | --- | --- |
| 8 | lotus | pink |
| 34 | sunflower | yellow |
| 5 | rose | red |

`with_columns`方法每次调用时，都会创建一个新表，所以原始表不受影响。 例如，表`an_example`仍然只有它创建时的两列。

```
flowers
```

| Number of petals | Name |
| --- | --- |
| 8 | lotus |
| 34 | sunflower |
| 5 | rose |

通过这种方式创建表涉及大量的输入。 如果数据已经输入到某个地方，通常可以使用 Python 将其读入表格中，而不是逐个单元格地输入。

通常，表格从包含逗号分隔值的文件创建。这些文件被称为 CSV 文件。

下面，我们使用`Table`的`read_table`方法，来读取一个 CSV 文件，它包含了一些数据，Minard 在他的拿破仑的俄罗斯战役的图片中使用。 数据放在名为`minard`的表中。

```
minard = Table.read_table('minard.csv')
minard
```

| Longitude | Latitude | City | Direction | Survivors |
| --- | --- | --- | --- | --- |
| 32 | 54.8 | Smolensk | Advance | 145000 |
| 33.2 | 54.9 | Dorogobouge | Advance | 140000 |
| 34.4 | 55.5 | Chjat | Advance | 127100 |
| 37.6 | 55.8 | Moscou | Advance | 100000 |
| 34.3 | 55.2 | Wixma | Retreat | 55000 |
| 32 | 54.6 | Smolensk | Retreat | 24000 |
| 30.4 | 54.4 | Orscha | Retreat | 20000 |
| 26.8 | 54.3 | Moiodexno | Retreat | 12000 |

我们将使用这个小的表格来演示一些有用的表格方法。 然后，我们将使用这些相同的方法，并在更大的数据表上开发其他方法。

### 表格的大小

`num_columns `方法提供了表中的列数量，`num_rows`是行数量。

```py
minard.num_columns
5
minard.num_rows
8
```

### 列标签

`labels `方法可以用来列出所有列的标签。 对于`minard`，并不是特别有用，但是对于那些非常大的表格，并不是所有的列都在屏幕上可见。

```py
minard.labels
('Longitude', 'Latitude', 'City', 'Direction', 'Survivors')
```

我们使用`relabeled `修改列标签。这会创建新的表格，并保留`minard`不变。

```
minard.relabeled('City', 'City Name')
```

| Longitude | Latitude | City Name | Direction | Survivors |
| --- | --- | --- | --- | --- |
| 32 | 54.8 | Smolensk | Advance | 145000 |
| 33.2 | 54.9 | Dorogobouge | Advance | 140000 |
| 34.4 | 55.5 | Chjat | Advance | 127100 |
| 37.6 | 55.8 | Moscou | Advance | 100000 |
| 34.3 | 55.2 | Wixma | Retreat | 55000 |
| 32 | 54.6 | Smolensk | Retreat | 24000 |
| 30.4 | 54.4 | Orscha | Retreat | 20000 |
| 26.8 | 54.3 | Moiodexno | Retreat | 12000 |

但是，这个方法并不修改原始表。

```
minard
```

| Longitude | Latitude | City | Direction | Survivors |
| --- | --- | --- | --- | --- |
| 32 | 54.8 | Smolensk | Advance | 145000 |
| 33.2 | 54.9 | Dorogobouge | Advance | 140000 |
| 34.4 | 55.5 | Chjat | Advance | 127100 |
| 37.6 | 55.8 | Moscou | Advance | 100000 |
| 34.3 | 55.2 | Wixma | Retreat | 55000 |
| 32 | 54.6 | Smolensk | Retreat | 24000 |
| 30.4 | 54.4 | Orscha | Retreat | 20000 |
| 26.8 | 54.3 | Moiodexno | Retreat | 12000 |

常见的模式时将原始名称`minard`赋给新的表，以便`minard `未来的所有使用，都会引用修改标签的表格。

```py
minard = minard.relabeled('City', 'City Name')
minard
```

| Longitude | Latitude | City Name | Direction | Survivors |
| --- | --- | --- | --- | --- |
| 32 | 54.8 | Smolensk | Advance | 145000 |
| 33.2 | 54.9 | Dorogobouge | Advance | 140000 |
| 34.4 | 55.5 | Chjat | Advance | 127100 |
| 37.6 | 55.8 | Moscou | Advance | 100000 |
| 34.3 | 55.2 | Wixma | Retreat | 55000 |
| 32 | 54.6 | Smolensk | Retreat | 24000 |
| 30.4 | 54.4 | Orscha | Retreat | 20000 |
| 26.8 | 54.3 | Moiodexno | Retreat | 12000 |

### 访问列中的数据

我们可以使用列标签来访问列中的数据数组。

```py
minard.column('Survivors')
array([145000, 140000, 127100, 100000,  55000,  24000,  20000,  12000])
```

五列的下标分别为`0, 1, 2, 3, 4`。`Survivors`列也可以使用列下标来访问。

```py
minard.column(4)
array([145000, 140000, 127100, 100000,  55000,  24000,  20000,  12000])
```

数组中的八个条目下标为`0, 1, 2, ..., 7`。列中的条目可以使用`item`访问，就像任何数组那样。

```py
minard.column(4).item(0)
145000
minard.column(4).item(5)
24000
```

### 处理列中的数据

因为列是数组，所以我们可以使用数组操作来探索新的信息。 例如，我们可以创建一个新列，其中包含 Smolensk 之后每个城市的所有幸存者的百分比。

```py
initial = minard.column('Survivors').item(0)
minard = minard.with_columns(
    'Percent Surviving', minard.column('Survivors')/initial
)
minard
```


| Longitude | Latitude | City Name | Direction | Survivors | Percent Surviving |
| --- | --- | --- | --- | --- | --- |
| 32 | 54.8 | Smolensk | Advance | 145000 | 100.00% |
| 33.2 | 54.9 | Dorogobouge | Advance | 140000 | 96.55% |
| 34.4 | 55.5 | Chjat | Advance | 127100 | 87.66% |
| 37.6 | 55.8 | Moscou | Advance | 100000 | 68.97% |
| 34.3 | 55.2 | Wixma | Retreat | 55000 | 37.93% |
| 32 | 54.6 | Smolensk | Retreat | 24000 | 16.55% |
| 30.4 | 54.4 | Orscha | Retreat | 20000 | 13.79% |
| 26.8 | 54.3 | Moiodexno | Retreat | 12000 | 8.28% |

要使新列中的比例显示为百分比，我们可以使用选项`PercentFormatter`调用`set_format`方法。 `set_format`方法接受`Formatter `对象，存在日期（`DateFormatter`），货币（`CurrencyFormatter`），数字和百分比。

```py
minard.set_format('Percent Surviving', PercentFormatter)
```

| Longitude | Latitude | City Name | Direction | Survivors | Percent Surviving |
| --- | --- | --- | --- | --- | --- |
| 32 | 54.8 | Smolensk | Advance | 145000 | 100.00% |
| 33.2 | 54.9 | Dorogobouge | Advance | 140000 | 96.55% |
| 34.4 | 55.5 | Chjat | Advance | 127100 | 87.66% |
| 37.6 | 55.8 | Moscou | Advance | 100000 | 68.97% |
| 34.3 | 55.2 | Wixma | Retreat | 55000 | 37.93% |
| 32 | 54.6 | Smolensk | Retreat | 24000 | 16.55% |
| 30.4 | 54.4 | Orscha | Retreat | 20000 | 13.79% |
| 26.8 | 54.3 | Moiodexno | Retreat | 12000 | 8.28% |

### 选择列的集合

`select `方法创建一个新表，仅仅包含指定的列。

```py
minard.select('Longitude', 'Latitude')
```


| Longitude | Latitude |
| --- | --- |
| 32 | 54.8 |
| 33.2 | 54.9 |
| 34.4 | 55.5 |
| 37.6 | 55.8 |
| 34.3 | 55.2 |
| 32 | 54.6 |
| 30.4 | 54.4 |
| 26.8 | 54.3 |

使用列索引而不是标签，也可以执行相同选择。

```py
minard.select(0, 1)
```


| Longitude | Latitude |
| --- | --- |
| 32 | 54.8 |
| 33.2 | 54.9 |
| 34.4 | 55.5 |
| 37.6 | 55.8 |
| 34.3 | 55.2 |
| 32 | 54.6 |
| 30.4 | 54.4 |
| 26.8 | 54.3 |

`select `的结果是个新表，即使当你选择一列时也是这样。

```
minard.select('Survivors')
```

| Survivors |
| --- |
| 145000 |
| 140000 |
| 127100 |
| 100000 |
| 55000 |
| 24000 |
| 20000 |
| 12000 |

要注意结果是个表格，不像`column`的结果，它是个数组。

```py
minard.column('Survivors')
array([145000, 140000, 127100, 100000,  55000,  24000,  20000,  12000])
```

另一种创建新表，包含列集合的方式，是`drop`你不想要的列。

```py
minard.drop('Longitude', 'Latitude', 'Direction')
```


| City Name | Survivors | Percent Surviving |
| --- | --- | --- |
| Smolensk | 145000 | 100.00% |
| Dorogobouge | 140000 | 96.55% |
| Chjat | 127100 | 87.66% |
| Moscou | 100000 | 68.97% |
| Wixma | 55000 | 37.93% |
| Smolensk | 24000 | 16.55% |
| Orscha | 20000 | 13.79% |
| Moiodexno | 12000 | 8.28% |

`select `和`drop`都不修改原始表格。 相反，他们创建了共享相同数据的新小型表格。 保留的原始表格是实用的！ 您可以生成多个不同的表格，只考虑某些列，而不用担心会互相影响。

```
minard
```

| Longitude | Latitude | City Name | Direction | Survivors | Percent Surviving |
| --- | --- | --- | --- | --- | --- |
| 32 | 54.8 | Smolensk | Advance | 145000 | 100.00% |
| 33.2 | 54.9 | Dorogobouge | Advance | 140000 | 96.55% |
| 34.4 | 55.5 | Chjat | Advance | 127100 | 87.66% |
| 37.6 | 55.8 | Moscou | Advance | 100000 | 68.97% |
| 34.3 | 55.2 | Wixma | Retreat | 55000 | 37.93% |
| 32 | 54.6 | Smolensk | Retreat | 24000 | 16.55% |
| 30.4 | 54.4 | Orscha | Retreat | 20000 | 13.79% |
| 26.8 | 54.3 | Moiodexno | Retreat | 12000 | 8.28% |

我们用过的所有方法都可以用在任何表格上。
